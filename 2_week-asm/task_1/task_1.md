# Задание

Ассемблерные коды всех программ будут разбираться в синтаксисе **Intel** при сборке с помощью gcc. Можно заметить, что коды всех программ разделены на секции (**.init**, **.plt**, **.text** и **.fini**), краткое описание которых можно найти [здесь](https://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/specialsections.html). Конкретно в данном разделе меня будет интересовать секция **.text**, так как именно в ней находится часть с кодом.

### Запуск функций с различным числом параметров

### 64-x битный режим

В дизасемблере 64-х битного режима в метке **_start** происходит запись эффективного адреса **[rip+0x2a2]** метки **main** в регистр **rdi**. 
В начале кода функции **main** происходит вызов инструкции **endbr64**, который необходим для корректного завершения indirect перехода между метками (see **Volume 2, Chapter 3, 3.3 Instructions (A-L)**):
```
0000000000001321 <main>:
    1321:	f3 0f 1e fa          	endbr64 
```
После идет пролог функции, в котором происходит запись старого значения **base pointer** в стек, после чего указатель стека копируется базу. После этих иструкций **rbp** указывает на базовый сегмент стекового фрейма **main**:
```
    1325:	55                   	push   rbp
    1326:	48 89 e5             	mov    rbp,rsp
```
Далее идет движение по стековому фрейму инструкцией с последующей записью 0 в регистр **eax** в качестве возвращаемого значения по умолчанию при выходе из **main**:
```
    1329:	48 83 ec 10          	sub    rsp,0x10
    132d:	89 f8                	mov    eax,edi
    132f:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
    1333:	88 45 fc             	mov    BYTE PTR [rbp-0x4],al
    1336:	b8 00 00 00 00       	mov    eax,0x0
```
Потом происходят вызовы функций с помощью **call** по меткам с записью аргументов в регистры **edi, esi, edx, ecx, r8d, r9d** в данном порядке по мере необходимости при вызове функций до 6 аргументов. Дальше аргументы кладутся в стек с перемещением его верхушки (пример для вызова **func7**):
```
    13ca:	48 83 ec 08          	sub    rsp,0x8
    13ce:	6a 07                	push   0x7
    13d0:	41 b9 06 00 00 00    	mov    r9d,0x6
    13d6:	41 b8 05 00 00 00    	mov    r8d,0x5
    13dc:	b9 04 00 00 00       	mov    ecx,0x4
    13e1:	ba 03 00 00 00       	mov    edx,0x3
    13e6:	be 02 00 00 00       	mov    esi,0x2
    13eb:	bf 01 00 00 00       	mov    edi,0x1
    13f0:	e8 64 fe ff ff       	call   1259 <func7>
```
В начале кода каждой функции **func** идут знакомые вызовы **endbr64** с изменением указателя базового сегмента на стек функции.
```
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   rbp
    114e:	48 89 e5             	mov    rbp,rsp
```
После происходит копирование значений из регистров в стековый фрейм функции с необходимым изменением адреса верхушки стека, соответствующим образу выше (при этом после 6 аргументов не происходит **pop** оставшихся аргментов). Затем происходит запись адреса константного строкового объекта (через **rip**) в регистр **rax**:
```
0000000000001163 <func1>:
    1163:	f3 0f 1e fa          	endbr64 
    1167:	55                   	push   rbp
    1168:	48 89 e5             	mov    rbp,rsp
    116b:	48 83 ec 10          	sub    rsp,0x10
    116f:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
    1172:	48 8d 05 b7 0e 00 00 	lea    rax,[rip+0xeb7]        # 2030 <_IO_stdin_used+0x30>
    1179:	48 89 c7             	mov    rdi,rax
```
После чего происходит вызов **printf** из динамически слинкованной стандартной библиотеки по специальной метке. Затем следуют инструкции **nop** (смысл которого я до сих пор не особо осознал), **leave** для очистки стека функции и **ret** для выхода из функции:
```
    117c:	e8 cf fe ff ff       	call   1050 <puts@plt>
    1181:	90                   	nop
    1182:	c9                   	leave  
    1183:	c3                   	ret    
```

### 32-x битный режим

В *32-х битном режиме* регистры стали 32-х битными (ba-dum-tss). 
Все функции вне зависимости от количества принимаемых аргументов имеют одинаковую реализацию, при этом в них появилась инструкция **call 1480 <__x86.get_pc_thunk.ax>**, по всей видимости необходимая для правильной передачи аргументов в стек функции:
```
000012ca <func7>:
    12ca:	55                   	push   ebp
    12cb:	89 e5                	mov    ebp,esp
    12cd:	53                   	push   ebx
    12ce:	83 ec 04             	sub    esp,0x4
    12d1:	e8 aa 01 00 00       	call   1480 <__x86.get_pc_thunk.ax>
    12d6:	05 02 2d 00 00       	add    eax,0x2d02
    12db:	83 ec 0c             	sub    esp,0xc
    12de:	8d 90 2c e1 ff ff    	lea    edx,[eax-0x1ed4]
    12e4:	52                   	push   edx
    12e5:	89 c3                	mov    ebx,eax
    12e7:	e8 64 fd ff ff       	call   1050 <puts@plt>
    12ec:	83 c4 10             	add    esp,0x10
    12ef:	90                   	nop
    12f0:	8b 5d fc             	mov    ebx,DWORD PTR [ebp-0x4]
    12f3:	c9                   	leave  
    12f4:	c3                   	ret    
```
При этом в **main** загрузка всех аргументов для вызова функций теперь происходит только через стек с указанной выше инструкцией.