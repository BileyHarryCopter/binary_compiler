# Задание

### <p style="text-align: center;"> Возврат 0 </p>

Способов прервать выполнение команды существует достаточно много (**int 0x80**, **sysenter/syscall** ), однако здесь воспользуемся инструкцией **syscall**. Для её выполнения необходимо передать параметры через регистры в 64-х битном режиме: в **rax** кладется номер системного вызова,  а его аргументы в регистры по возрастанию: **rdi, rsi, rdx, r10, r8, r9**, в случае нехватки регистров - аргументы помещаются в стек. Из заголовочного файла **unistd_64.h** (который можно открыть в */usr/include/x86_64-linux-gnu/asm/unistd_64.h*) достаем номер вызова **exit**, а в регистр **rdi** помещаем возвращаемое значение в виде нуля (xor %rdi, %rdi обнуляет регистр).

Для сборки файла **return_zero.s**:
```bash
    as --64 return_zero.s -o return_zero.o
    ld -dn -melf_x86_64 return_zero.o -o return_zero
```

### <p style="text-align: center;"> hello_world.s </p>

Поступим аналогично способу выше для вызова **write**. **Opcode** вызова **write** равен 1, поэтому в **rax** кладем 1. Из **man 2 write** получим:
```bash
    ssize_t write(int fd, const void *buf, size_t count);
```

Соответственно для вывода в **stdout** в **rdi** необходимо положить 1. Далее кладем адрес переменной **msg** и длину сообщения в следущие регистры:
```
    # write (1, "Hello, World!\n", 14)
    mov $1,    %rax
    mov $1,    %rdi
    mov $msg,  %rsi
    mov $len,  %rdx
    syscall
```

Информацию о **msg** поместим в секцию постоянных данных **.rodata**. С помощью директивы **.asciz** поместим строку по соответсвующему адресу в памяти, а с помощью **.equ** положим значение **len** равным длине **msg**, высчитываемого с помощью паттерна **. - msg**:
```
    msg:
    .asciz "Hello_ World!\n"
    .equ   len, . - msg
```

### <p style="text-align: center;"> Вывод аргументов бинарника </p>

Для выяснения регистров, использующихся для передачи аргументов бинарника в исходный код, запустим бинарник файла **argc_argv.c**  с опцией передачи аргументов:
```
    gcc -O0 -g argc_argv.c -o argc_argv
    gdb --args ./argc_argv --Dany --007
```

Поставив **breakpoint** на метку вхождения в **main**, узнаем информацию о регистрах:
```
    Breakpoint 1, main (argc=3 '\003', argv=0x7fffffffde38) at argc_argv.c:6
    6	    return 0;
    (gdb) info registers
    rax            0x3                 3
    ...
    rdi            0x3                 3
    ...
    r12            0x7fffffffde38      140737488346680
    ...
```

Откуда видим, что значение кол-ва аргументов располагается одновременно в регистрах **rax** и **rdi**, а адрес начала массива аргументов в **r12**. Аналогичным образом можно понять, что адрес первого аргумента командной строки находится в ячейке со смещением вниз по стэке от **rsp** на 8. 

Поняв расположение всех данных, напишем обход массива аргументов в цикле с меткой вхождения **loop**. В начале происходит проверка на то, не указывает ли текущий аргумент на NULL. В случае положительности выходим из цикла по метке **exit**, в которой перед завершением программы происходит перенос строки. Далее следует алгоритм нахождения длины текущего строчного аргумента (взят [отсюда]( http://www.int80h.org/strlen/)). После происходит вывод этого аргумента с печатью знака пробела.

